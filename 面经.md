# [Javascript查漏补缺](#Javascript)

## 一、隐式转换规则

- ### 数字转换：

  #### String   :    等价于使用Number（）函数进行转换的结果,<font color="red">非数字字符串 = Na N</font>；空字符串 = 0；’  正负Infinity ‘   =    数字类型Infinity  ；<font color='red'>'  {}  '   =   NaN</font>   ;     <font color='red'>‘[]’ = 0</font>  ;

  #### undefined :  Na N

  #### null : 0

  ####  Boolean : true 转换为 1，false 转换为 0。 

- ### 布尔值转换：

  #### 除null、undefined、‘’、""、Na N、+0、-0外都为true

- ### 字符串转换：正常思路

## 二、JavaScript垃圾回收机制

- [什么是垃圾回收机制？](#什么是垃圾回收机制？)

- [为什么要进行垃圾回收?](#为什么要进行垃圾回收?)

- [垃圾回收是怎样进行的？](# 垃圾回收是怎样进行的？)

  

  ### 什么是垃圾回收机制？

  内存泄露：指已经动态分配的堆内存，没有得到及时释放，造成的内存浪费

  ​		常见内存泄露： 使用不当的闭包将会在IE(IE 9之前)中造成内存泄漏 ；未及时清理的定时器、回调函数等

  什么是垃圾回收机制？

  ​		垃圾回收机制又称作G C（Garbage Collection）:工作在J S引擎内部，原理是找到内存空间中的程序用不到的内存空间或者是之前用过了后面不会在用的内存空间并回收

  ### 为什么要进行垃圾回收?

  程序运行需要内存，只要程序提出要求，操作系统必须满足；

  对于持续运行占用内存的程序，必须要及时释放，否则占用内存越来越大，轻则影响性能，重则程序崩溃。

### 		垃圾回收是怎样进行的？

- ​	标记清除算法（最常用）

  ​	**标记阶段**：为所有活动对象做上标记

  ​	**清除阶段**：把没有标记的非活动对象销毁

- ​    引用清除算法

## 三、展开运算符对对象的使用

```javascript
let obj = {name:'ybj',age:18};

/*展开运算符不能展开对象*/
console.log(...obj);//obj is not iterable

/*可以复制对象*/
let newObj = {...obj};
console.log(newObj);//{name:'ybj',age:18}

/*复制对象，并对对象已有的属性更改，或者添加属性*/
let newObj1 = {...obj,name:'uahs'}
console.log(newObj1);//{name:'uahs',age:18}
```

## 四、for	in和Object.keys()的区别

​	forin遍历对象属性，会获取对象的自有属性和原型对象上的属性

​	Object.keys()遍历对象属性，只能获取对象的自有属性

​	都不能获取以symbol为键的属性

## 五、图片预加载

```html
<img id ='imgObj' src='https://a.axihe.com/assets/img/anbang-weixin.jpg'/>

<script>
    let imgObj = document.getElementById('imgObj');
    function yujiazai(tempSrc){
        let imgObj1 = new Image();//创建img标签
       	imgObj1.src = tempSrc;
        imgObj1.onload = function(){
            imgObj.src = this.src;
          	imgObj.height = 50;
        	imgObj.width = 50;
        }
    }
</script>
```

## 六、Promise

**promise串联多个任务：解决回调地狱问题**

回调地狱：一个函数的结果作为下一个回调函数的执行条件，层层嵌套形成回调地狱

promise：一个函数的结果决定promise的状态，promise的状态决定回调函数的执行条件

**promise异常穿透：**

穿透过程中相当于`reason => {throw reason}`

**如何中断Promise链：**

传递给下一个回调函数一个pending状态的promise，即`return new Promise(()=>{})`。下一个回调函数，根据上一个回调函数的返回结果来决定，如果返回pending状态的promise，则会终止在这个回调函数。

# HTML拾遗

## 关于<!DOCTYPE>

**作用**：用于告知浏览器使用的HTML版本

在HTML4中需要引用文档类型声明（DTD），才能浏览器能够正确渲染内容，一共有三种类型：strict（不包括过时元素和框架集）、transitional（包括过时元素不包括框架集）、frameset（全包括）

在html5中只有一种





## HTML5新特性

- ### 新增语义化标签：header、footer、nav、section、aside、hgroup

  ​	优点：便于阅读，利于开发和维护；利于搜索引擎优化（SEO）；方便其他设备解析

- ### 废除元素

  ​	1.纯表现形式的标签，这些标签可以用css来代替

  ​	2.frame框架相关标签，对页面存在负面作用

  ​	3.只有部分浏览器支持的元素

  

- ### 新增API

  1. Canvas画布：通过Javascript绘制图案
  2.  音视频标签：
  3. WebsocketAPI：基于HTTP协议的浏览器与服务器之间通信的全双工通信协议，时效性更强，控制开销更少，无跨域问题，支持扩展
  4. 增强型表单
  5. drag拖拽
  6. Web Storage API：localStorage和sessionStorage
  7. Web Workers  API：独立于主线程的后台线程，针对JS单线程的解决方案，可以额外运行JS脚本。使用postMassage实现进程之前通信

## DOM

- ### 事件捕获与事件冒泡

  ​	1.事件捕获： addEventListener 第三个参数为true

  ​		指事件从根元素向下传播到实际触发节点，依次检查经过节点是否绑定事件监		听函数，如果有且设定为捕获阶段则执行		

  ​	2.事件冒泡：addEventListener 第三个参数为false

  ​		指事件从实际触发节点向上传播到根节点，依次检查经过节点是否绑定事件监		听函数，如果有且设定为冒泡阶段则触发

- ### 事件委托

  ​	<font color="pink">利用事件冒泡的原理</font>，给父元素绑定事件监听函数，则可以管理所属下一类子事件

  **缺点：**部分事件没有冒泡机制（blur、focus）

  ​			频繁触发的事件不适合使用

- ## defer和async的区别

  ​	defer：在document解析完成之后，执行JS脚本

  ​	async：在document解析过程时，JS脚本一旦加载好就立即执行，仍然会阻塞文document解析

## 标签拾遗

### 表单元素

#### 	input表单元素

- 配合<label for="input的id">标签使用，绑定指定input标签，点击lebal就会触发input标签
- <input alt="图像输出的替代文本" value="表单元素值" type="">

#### 	form表单域

​	用于提交表单元素到后台服务器

- 属性

	action：定义表单提交时的动作

	method：规定表单提交使用的HTTP方法（GET/POST），默认为GET

	name：input必须设置name属性，才能被form正确提交

	target：规定action属性中地址的目标

# CSS拾遗

### 外边距（Margin）合并-嵌套块元素塌陷

​	对于两个嵌套关系的块元素，同时在垂直方向存在外边距时，父级块元素会塌陷两个块元素的margin中较大的值

### 元素隐藏与显示

- display:隐藏元素，不保留位置
- visibility:隐藏元素，保留位置
- overflow：隐藏溢出元素

# Broswer浏览器

## 浏览器内核

- chrome：Blink内核
- opera：Blink内核
- firefox：Gecko内核
- ie：Trident内核
- safari：Webkit内核

## 从输入URL到页面加载显示

1. #### 从浏览器接收 url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程 之间的关系）

   **进程与线程**

   - 进程是CPU资源分配的最小单位，也可以说是拥有资源能够能够**独立**运行的最小单位
   - 线程是CPU调度的基本单位，一个进程内的有多个线程共享资源

   **浏览器基础**

   - 浏览器是多进程的（一个浏览器主进程、多个渲染进程、多个插件插件进程、一个GPU进程、一个网络进程）

   - 多进程优点

     避免单个页面影响整个浏览器

     避免第三方插件影响整个浏览器

     有利于发挥多核的优势

     方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

   - 渲染进程（又称浏览器内核），包括GUI线程、JS引擎、事件线程、定时触发器线程、异步http请求线程

     ​	GUI线程：负责渲染浏览器界面，解析HTML、CSS，构建DOM树和Render树，布局绘制。当页面需要重绘或者回流时，该线程就会执行

     ​	JS线程：负责处理JS脚本，运行程序。

     ​	事件线程：用于控制EventLoop，将异步任务添加到事件线程中，当异步任务触发时，将其添加到任务队列中，等待JS处理。

     ​	定时器线程：setTimeout和setInterval所在线程，由于JS是单线程的，有可能影响计时，因此将计时任务交给定时器线程，时间到了就将任务交给**事件队列**

     ​	异步http请求线程：当有状态变更的回调函数时，放入**事件队列**中，等待JS处理。

      ![img](https://img-blog.csdnimg.cn/20200401002947942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3NjkxMw==,size_16,color_FFFFFF,t_70) 

   - JS引擎线程与GUI渲染线程互斥

     由于JS是可以操作DOM元素的，因此两个线程不能同时操作，JS脚本阻塞会影响GUI的渲染，出于对性能的考虑，应该在html标签之后引入script标签（async异步加载JS脚本和defer延迟加载JS脚本）

   - H5API：WebWorker

       它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。 可以在独立线程中处理一些计算密集型或高延迟的任务，从而允许主线程（通常是 UI 线程）不会因此被阻塞或拖慢，线程之间通过内置postMassage进行通信。

      

     ```javascript
     //创建woker实例对象，执行指定JS脚本，该脚本必须遵守同源策略
     const myFirstWoker = new Worker(aURL, options);
     ```

   **浏览器缓存**

   ​	浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请·	求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头	的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。

    ![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242491976-285dbbac-7d90-4d8b-b376-258b507278b4.webp) 

   - 浏览器每次发起请求都会先查看浏览器缓存

   - 浏览器每次得到返回的请求结果都会将缓存标识和结果存入浏览器缓存中

   - 根据浏览器是否需要发送http请求，分为**强制缓存**和**协商缓存**

     **强制缓存**是向浏览器查询结果，并根据缓存规则决定是否使用。

     当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control（http/1.1）优先级比Expires（http/1.0）高。

     **协商缓存**就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，服务器根据缓存标识决定是否使用缓存。

     协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match。其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高，同时存在则只有Etag / If-None-Match生效。

      ![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494623-5e22c25c-7fef-4568-b970-69dfd58199dd.webp) 

     

2. 开启⽹络线程到发出⼀个完整的 HTTP 请求（这⼀部分涉及到dns查询， TCP/IP 请求， 五层因特⽹协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以 及后台内部的处理等等）

4. 后台和前台的 HTTP 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）

5. 单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catch- control 等）

6. 浏览器接收到 HTTP 数据包后的解析流程（解析 html -词法分析然后解析成 dom 树、解 析 css ⽣成 css 规则树、合并成 render 树，然后 layout 、 painting 渲染、复合图 层的合成、 GPU 绘制、外链资源的处理、 loaded 和 DOMContentLoaded 等）

7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）

8. JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作 ⽤域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）

## OSI七层模型/TCP四层模型

- ### OSI七层模型

  物理层：

  数据链路层：

  网络层：

  运输层：

  会话层：

  表示层：

  应用层：

- ### TCP四层模型

  网络接口层：

  网际层：

  运输层：

  应用层：

## HTTP与HTTPS

### HTTP

-  HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。 

- 特点：无状态、明文、不安全

- HTTP1.1支持长连接，管道网络传输减少响应时间，但要造成队头阻塞能够使用同一个域名建立多个持久连接（chrome是六个）解决

- 优化：利用缓存技术尽量避免http请求；

  ​		   利用代理服务器减少重定向次数，使用打包工具减少请求次数，

  ​		   数据压缩

### HTTPS

-  HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。
-  透明性：混合加密；完整性：摘要算法；真实性：数字证书；
- 密钥交换算法：RSA（安全性较差，不支持前向加密）、ECDHE（更好）

### 区别

- HTTPS在HTTP和TCP之间加入SSL/TLS安全协议，加密传输数据
- HTTPS需要经历TCP握手和SSL/TLS握手才能进行加密传输
- HTTP服务器监听80端口；HTTPS服务器监听443端口
- 使用HTTPS的服务器需要向CA申请数字证书

## WebSocket

- #### 是什么？

  HTML5开始提供的一种浏览器与服务器进行<font color="pink">全双工通信的通信协议</font>，复用HTTP握手信道（通过HTTP请求报文升级通信服务协议）

- #### 优点？

  可以发送⽂本，也可以⼆进制⽂件 

  相比于http1.0的短连接和1.1的长连接，<font color="pink">实时性更强</font>

  相比于http每次都要携带完整的请求头，<font color="pink">控制开销更少</font>

  无跨域问题

  支持扩展

- #### 应用场景

  弹幕、聊天室

  ```javascript
  const ws = new Websocket();
  ```

  