# Javascript拾遗

## 一、隐式转换规则

- ### 数字转换：

  #### String   :    等价于使用Number（）函数进行转换的结果,<font color="red">非数字字符串 = Na N</font>；空字符串 = 0；’  正负Infinity ‘   =    数字类型Infinity  ；<font color='red'>'  {}  '   =   NaN</font>   ;     <font color='red'>‘[]’ = 0</font>  ;

  #### undefined :  Na N

  #### null : 0

  ####  Boolean : true 转换为 1，false 转换为 0。 

- ### 布尔值转换：

  #### 除null、undefined、‘’、""、Na N、+0、-0外都为true

- ### 字符串转换：正常思路

## 二、JavaScript垃圾回收机制

- [什么是垃圾回收机制？](#什么是垃圾回收机制？)

- [为什么要进行垃圾回收?](#为什么要进行垃圾回收?)

- [垃圾回收是怎样进行的？](# 垃圾回收是怎样进行的？)

  

  ### 什么是垃圾回收机制？

  内存泄露：指已经动态分配的堆内存，没有得到及时释放，造成的内存浪费

  ​		常见内存泄露： 使用不当的闭包将会在IE(IE 9之前)中造成内存泄漏 ；未及时清理的定时器、回调函数等

  什么是垃圾回收机制？

  ​		垃圾回收机制又称作G C（Garbage Collection）:工作在J S引擎内部，原理是找到内存空间中的程序用不到的内存空间或者是之前用过了后面不会在用的内存空间并回收

  ### 为什么要进行垃圾回收?

  程序运行需要内存，只要程序提出要求，操作系统必须满足；

  对于持续运行占用内存的程序，必须要及时释放，否则占用内存越来越大，轻则影响性能，重则程序崩溃。
  
  #### 		垃圾回收是怎样进行的？
  
- ​	标记清除算法（最常用）

  ​	**标记阶段**：为所有活动对象做上标记

  ​	**清除阶段**：把没有标记的非活动对象销毁

- ​    引用清除算法

## 三、展开运算符对对象的使用

```javascript
let obj = {name:'ybj',age:18};

/*展开运算符不能展开对象*/
console.log(...obj);//obj is not iterable

/*可以复制对象*/
let newObj = {...obj};
console.log(newObj);//{name:'ybj',age:18}

/*复制对象，并对对象已有的属性更改，或者添加属性*/
let newObj1 = {...obj,name:'uahs'}
console.log(newObj1);//{name:'uahs',age:18}
```

## 四、forin和Object.keys()的区别

​	forin遍历对象属性，会获取对象的自有属性和原型对象上的属性

​	Object.keys()遍历对象属性，只能获取对象的自有属性

​	都不能获取以symbol为键的属性

## 五、图片预加载

```html
<img id ='imgObj' src='https://a.axihe.com/assets/img/anbang-weixin.jpg'/>

<script>
    let imgObj = document.getElementById('imgObj');
    function yujiazai(tempSrc){
        let imgObj1 = new Image();//创建img标签
       	imgObj1.src = tempSrc;
        imgObj1.onload = function(){
            imgObj.src = this.src;
          	imgObj.height = 50;
        	imgObj.width = 50;
        }
    }
</script>
```

## 六、Promise

**promise串联多个任务：解决回调地狱问题**

回调地狱：一个函数的结果作为下一个回调函数的执行条件，层层嵌套形成回调地狱

promise：一个函数的结果决定promise的状态，promise的状态决定回调函数的执行条件

**promise异常穿透：**

穿透过程中相当于`reason => {throw reason}`

**如何中断Promise链：**

传递给下一个回调函数一个pending状态的promise，即`return new Promise(()=>{})`。下一个回调函数，根据上一个回调函数的返回结果来决定，如果返回pending状态的promise，则会终止在这个回调函数。

### `require`与`import`的区别

- `require`支持 **动态导入**，`import`不支持，正在提案 (babel 下可支持)
- `require`是 **同步** 导入，`import`属于 **异步** 导入
- `require`是 **值拷贝**，导出值变化不会影响导入值；`import`指向 **内存地址**，导入值会随导出值而变化


作者：郭东东链接：https://juejin.cn/post/6844903776512393224来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 原型、原型链

原型：任意对象的prototype属性指向的对象

#### 原型链

原型链是一个概念，当我们访问一个对象的属性时，当对象本身上没有这个属性，就会通过隐式原型`__proto__`，到对象的原型对象上面去找，一直找到顶级原型对象上，这个之间的连接称作原型链。

### 函数作用域

### 执行上下文

执行上下文是变量提升和函数提升的根本原理，在函数执行之前创建。

#### 全局执行上下文

在执行之前产生，对全局数据进行预处理，将var定义的变量赋值为undefined同时添加到window对象身上；函数声明式添加为window的方法，this执行window。

#### 函数执行上下文

在函数执行之前被调用，初始化this和arguments，函数提升和变量提升

### 事件轮询（Eventloop）

#### 宏队列与微队列

先执行整个微队列，然后执行宏队列，宏队列中每个任务执行前都要检查微队列，如果有要先执行整个微队列。

- 宏队列事件：DOM事件回调、异步http请求回调、setTimeout、setInterval、setImmedia
- 微队列事件：promise回调、mutationOberserve回调

### cookie、sessionstorage、localstorage区别

- cookie是解决http无状态的机制，用于标识用户身份，发送请求时自动携带，大小为4kb，以key-value的字符串形式存在，同时支持设置属性

GET和POST的区别

# HTML拾遗

### 关于<!DOCTYPE>

**作用**：用于告知浏览器使以什么文档标准解析文档

标准模式：以该浏览器支持的最高标准运行

兼容模式：以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。

**为什么HTML5只写DOCTYPE？**

HTML4基于SGML，需要引用文档类型声明（DTD），才能浏览器能够正确渲染内容，一共有三种类型：strict（不包括过时元素和框架集）、transitional（包括过时元素不包括框架集）、frameset（全包括）

HTML5不基于SMGL，不需要引用文档类型声明，但需要使用DOCTYPE规范浏览器的行为

### 行内、块、空元素有哪些？

- 行内元素：a、b、span、select、strong、img、input
- 块元素：div、ul、ol、li、p、h系列、dl、dt
- 空元素（自闭合）：img、input、link、meta、br、hr



### meta标签

用于描述页面

- `name="viewport"`移动端适配

  ```html
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  ```

  

  `heigh/width` ：高度(数值/device-height) 

  `initial-scale` ：初始缩放比例 

  `maximum-scale` ：最大缩放比例 

  `minimum-scale` ：最小缩放比例 

  `user-scalable` ：是否允许用户缩放(yes/no）

- `name:"robots"`:搜索引擎检索方式

  `none`：文件将不被检索，且页面上的链接不可以被查询； 

  `index`：文件将被检索； 

  `follow`：页面上的链接可以被查询； 

  `noindex`：文件将不被检索； 

  `nofollow`：页面上的链接不可以被查询。

- `name:"utf-8"`文档编码类型

- `name:"keywords"`页面关键词

- `name:"description"`页面描述

### 单页面与多页面应用

|                 SPA                  |                 MPA                 |
| :----------------------------------: | :---------------------------------: |
|           单页面+路由组件            |            多个完整页面             |
|       不利于SEO（可以借助SSR）       |              有利于SEO              |
| 页面切换快；初次加载时，加载文件较多 | 切换页面速度慢；网速差时，体验不好  |
|               路由跳转               |              链接跳转               |
|           使用全局变量保存           | 利用本地缓存、URL参数、调用接口保存 |



### HTML5新特性

- ### 新增语义化标签：header、footer、nav、section、aside、hgroup

  ​	优点：结构更清晰便于阅读，利于开发和维护；利于搜索引擎解析（SEO）；方便其他设备解析

- ### 新增API

  1. Canvas画布：通过Javascript绘制图案
  2.  音视频标签：
  3. WebsocketAPI：基于HTTP协议的浏览器与服务器之间通信的全双工通信协议，时效性更强，控制开销更少，无跨域问题，支持扩展
  4. 增强型表单
  5. drag拖拽
  6. Web Storage API：localStorage和sessionStorage
  7. Web Workers  API：独立于主线程的后台线程，针对JS单线程的解决方案，可以额外运行JS脚本。使用postMassage实现进程之前通信

### src与href的区别

- src：是对资源的引用，会将其指向的资源下载并应用到文档中。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到该资源加载、编译、执行完毕。常用于`<img>`、`<script>`、`<iframe>`
- href：是指向网络资源所在的超文本链接，建立当前元素或文档的链接关系。并行下载网络资源，不会停止当前文档的解析。常用于`<link>`、`<a>`

### DOM

- ### 事件捕获与事件冒泡

  ​	1.事件捕获： addEventListener 第三个参数为true

  ​		指事件从根元素向下传播到实际触发节点，依次检查经过节点是否绑定事件监		听函数，如果有且设定为捕获阶段则执行		

  ​	2.事件冒泡：addEventListener 第三个参数为false

  ​		指事件从实际触发节点向上传播到根节点，依次检查经过节点是否绑定事件监		听函数，如果有且设定为冒泡阶段则触发

- ### 事件委托

  ​	<font color="pink">利用事件冒泡的原理</font>，给父元素绑定事件监听函数，则可以管理所属下一类子事件

  **缺点：**部分事件没有冒泡机制（blur、focus）

  ​			频繁触发的事件不适合使用

- ## defer和async的区别

  ​	defer：在document解析完成之后，执行JS脚本

  ​	async：在document解析过程时，JS脚本一旦加载好就立即执行，仍然会阻塞文档解析

### 表单元素

#### 	input表单元素

- 配合<label for="input的id">标签使用，绑定指定input标签，点击lebal就会触发input标签
- <input alt="图像输出的替代文本" value="表单元素值" type="">

#### 	form表单域

​	用于提交表单元素到后台服务器

- 属性

	action：定义表单提交时的动作

	method：规定表单提交使用的HTTP方法（GET/POST），默认为GET

	name：input必须设置name属性，才能被form正确提交

	target：规定action属性中地址的目标

# CSS拾遗

### 选择器优先级

！important > 内联style > id > 类、伪类、属性 > 元素、伪元素

### 伪类与伪元素的区别

- 伪类： 伪类用于当已有元素处于的某个状态时，为其添加对应的样式 
- 伪元素： 伪元素用于创建一些不在文档树中的元素，并为其添加样式。 

### 覆盖规则

- 继承冲突时，祖先优先
- 继承与指定样式冲突时，指定优先
- 指定样式冲突时，权值高者优先
- 权值相同时，新鲜的最先
- ！important不被覆盖

### 继承

无继承属性：display、盒子模型属性、背景属性、定位属性、文本部分属性（vertical-align，text-decoration，white-space）

有继承属性：字体属性、文本部分属性(color、line-height)

### 了解的布局方式

- 标准文档流

- 浮动布局

- 定位布局

- flex布局：任何一个容器都可以设置flex，设置后子元素的float、clear、vertical-align失效

- 响应式布局：利用媒体查询`@media and 设备():{}`

- 移动端流式布局：

  [视频资料]: https://www.bilibili.com/video/BV1pE411q7FU?p=408

### display的block、inline和inline-block的区别

block：设置为块级元素属性，独占一行，能够设置width、height、margin、padding

inline-block：设置为行内块元素属性，不会独占一行，拥有块元素的属性

inline：设置会行内元素，不会独占一行，设置width、height无效，只能设置水平方向的margin和padding

### 元素居中的方案

#### 水平居中

- 行内元素 =》text-align:center

- 块级元素 =》margin：0 auto

- 定位方案 =》

  ```css
  .father{
      position:relative;
  }
  .son1{
      positon:absolute;
      left:50%;
      transform:translateX(-50%);
  }
  .son2{
      position:absolute;
      width:100px;
      left:50%;
      transform:translateX(50px);
  }
  .son3{
      position:absolute;
      width:固定;
      left:0;
      right:0;
      margin:0 auto;
  }
  ```

- flex方案 =》

  ```css
  .father{
      display:flex;
      justify-content:center;
  }
  ```

#### 垂直居中

- 单行文本 =》 父元素设置height ；目标元素设置line-height等于height

- 行内块元素 =》 

  ```css
  .parent::after, .son{
      display:inline-block;
      vertical-align:middle;
  }
  .parent::after{
      content:'';
      height:100%;
  }
  ```

- 定位方案

- flex方案



### CSS动画

定义关键帧`@keyframes name`

调用动画`animation name`并且配置一系列动画属性

### BFC

[BFC是什么？]: https://blog.csdn.net/weixin_45817492/article/details/111232602

​		**概念**（Bloack- Formatting-Context）块格式化上下文：是一个CSS布局概念，即块内元素不会影响外面的元素。

​		**创建**：`overflow：hidden`、`position：absolute或者fixed`、`display：inline-block或者flex`等

​		**应用**: 1.分属于不同的`BFC`时,可以防止`margin`重叠 2.清除浮动 3.自适应多栏布局 

### 外边距（Margin）合并

#### 相邻块元素垂直外边距合并

​	对于垂直方向兄弟块元素，在**相邻侧**有margin时，两者垂直间距不是二者margin之和，而是两者中较大的一个。

#### 嵌套块元素垂直外边距塌陷

​	对于垂直方向父子块元素，在**同侧**有margin时，父级块元素会塌陷父子块元素的margin中较大的值

### 盒模型

标准盒模型（默认）：width和height只包含了content

怪异盒模型（box-sizing：border-box）:width和height包含了content、border、padding、margin

### CSS预处理与后处理器

css预处理器：为CSS增加一些简单的编程特性，使css更加简洁屏幕不同浏览器私有语法的差异，增加可读性、可维护性

后处理器：webpack中的postcss-loader，解决跨浏览器兼容性问题

### 元素隐藏与显示

- display:隐藏元素，不保留位置，不能响应绑定监听
- visibility:隐藏元素，保留位置，不能响应绑定监听
- overflow：隐藏溢出元素
- opacity:0 ：隐藏元素，占据位置，能够响应绑定监听

### 文本溢出

#### 单行文本溢出

```css
.div{
    over-flow:hidden;//溢出隐藏
    white-space:nowrap;//不换行，显示单行
    text-overflow:ellipsis;//溢出文本显示形式
}
```

#### 多行文本溢出隐藏

```css
.div{
    over-flow:hidden;//溢出隐藏
    text-overflow:ellipsis;//溢出文本形式
    display:-webkit-box;//设置为弹性盒子
    -webkit-box-orient:vertical;//元素排列方式
    -webkit-line-clamp:3;//排列行数
}
```

### z-index失效情况

 z-index元素的position属性需要是relative，absolute或是fixed。 

- 父元素为relative时，子元素的z-index失效
- 元素未设置relative，absolute或是fixed。
- 元素设置z-index同时，设置float。

### link和@import的区别

- link是html标签，@import是语法只能加载css
- link兼容所有浏览器，@import不兼容版本ie5以下浏览器
- link在页面加载时，同步加载；@import是在页面加载完毕后，才进行加载
- link可以通过js操作DOM动态引入样式表；@import无法改变

### CSS布局单位

- px：CSS像素
- em：相对父元素字体大小倍数
- rem：相对根元素字体大小倍数
- vh/vw：相对于视窗分成100份
- %：相对于父元素，部分相对于自身

### flex常见布局

**两栏布局**：左边固定，右边自适应

```less
/*利用浮动布局*/
.left {
  	float: left;
  	width: 200px;
}
.right {
 	margin-left: 200px;
    width:auto;//默认
}
```

```less
/*利用浮动布局，加上BFC*/
.left {
  	float: left;
  	width: 200px;
}
.right{
	overflow:hidden;//触发BFC
}
```

```less
/*利用flex布局*/
.container{
    display:flex;
}
.left{
    width:200px;
}
.right{
    flex:1;
}
```

**等宽布局**：

```less
<body>
<div id="parent">
    <div class="column">1 <p>我是文字我是文字我输文字我是文字我是文字</p></div>
    <div class="column">2 <p>我是文字我是文字我输文字我是文字我是文字</p></div>
    <div class="column">3 <p>我是文字我是文字我输文字我是文字我是文字</p></div>
    <div class="column">4 <p>我是文字我是文字我输文字我是文字我是文字</p></div>
</div>
</body>
#container{
    margin-left:-15px;
    display:flex;
    height:500px;
}
.column{
    flex:1;
    margin-left:15px;
}
```

**九宫格布局：**

```less
 <div id="parent">
      <div class="row">
        <div class="item">1</div>
        <div class="item">2</div>
        <div class="item">3</div>
      </div>
      <div class="row">
        <div class="item">4</div>
        <div class="item">5</div>
        <div class="item">6</div>
      </div>
      <div class="row">
        <div class="item">7</div>
        <div class="item">8</div>
        <div class="item">9</div>
      </div>
  </div>
<style>
    #id{
      display: flex;
    }
    .row{
      flex: 1;
      display:flex;
    }
    .item{
      width: 50px;height: 50px;
      margin-left: -5px;
      margin-bottom: -5px;
      border: 5px solid blue;
    }
    .item:hover{
      border: 5px solid red;
      /* z-index: 1; */
    }
  </style>
```

#### 三角

```less
div{
    width:0;
    height:0;
    border-bottom: 50px solid red;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
    //旋转角度
    transform:rotate(90deg);
}
```

#### 圆角

```less
div{
    width:0;
    height:0;
	border:100px solid transparent;
    border-radius:100px;
    border-top-color:res;
}
```

#### 0.5px的线

```less
div{
  transform: scale(1,0.5);
  background-color: red;
  height: 1px;
}
```

# Broswer浏览器

## 浏览器内核

- chrome：Blink内核
- opera：Blink内核
- firefox：Gecko内核
- ie：Trident内核
- safari：Webkit内核

## 从输入URL到页面加载显示

1. #### 浏览器接收 url 查询浏览器缓存

   #### 进程与线程

   - 进程是CPU资源分配的最小单位，也可以说是拥有资源能够能够**独立**运行的最小单位
   - 线程是CPU调度的基本单位，一个进程内的有多个线程共享资源

   **浏览器基础**

   - 浏览器是多进程的（一个浏览器主进程、多个渲染进程、多个插件插件进程、一个GPU进程、一个网络进程）

   - 多进程优点

     避免单个页面影响整个浏览器

     避免第三方插件影响整个浏览器

     有利于发挥多核的优势

     方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

   - 渲染进程（又称浏览器内核），包括GUI线程、JS引擎、事件线程、定时触发器线程、异步http请求线程

     ​	GUI线程：负责渲染浏览器界面，解析HTML、CSS，构建DOM树和Render树，布局绘制。当页面需要重绘或者回流时，该线程就会执行

     ​	JS线程：负责处理JS脚本，运行程序。

     ​	事件线程：用于控制EventLoop，将异步任务添加到事件线程中，当异步任务触发时，将其添加到任务队列中，等待JS处理。

     ​	定时器线程：setTimeout和setInterval所在线程，由于JS是单线程的，有可能影响计时，因此将计时任务交给定时器线程，时间到了就将任务交给**事件队列**

     ​	异步http请求线程：当有状态变更的回调函数时，放入**事件队列**中，等待JS处理。

      ![img](https://img-blog.csdnimg.cn/20200401002947942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI3NjkxMw==,size_16,color_FFFFFF,t_70) 

   - JS引擎线程与GUI渲染线程互斥

     由于JS是可以操作DOM元素的，因此两个线程不能同时操作，JS脚本阻塞会影响GUI的渲染，出于对性能的考虑，应该在html标签之后引入script标签（async异步加载JS脚本和defer延迟加载JS脚本）

   - H5API：WebWorker

       它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。 可以在独立线程中处理一些计算密集型或高延迟的任务，从而允许主线程（通常是 UI 线程）不会因此被阻塞或拖慢，线程之间通过内置postMassage进行通信。

      

     ```javascript
     //创建woker实例对象，执行指定JS脚本，该脚本必须遵守同源策略
     const myFirstWoker = new Worker(aURL, options);
     ```

   **浏览器缓存**

   ​	浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请·	求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头	的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。

    ![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242491976-285dbbac-7d90-4d8b-b376-258b507278b4.webp) 

   - 浏览器每次发起请求都会先查看浏览器缓存

   - 浏览器每次得到返回的请求结果都会将缓存标识和结果存入浏览器缓存中

   - 根据浏览器是否需要发送http请求，分为**强制缓存**和**协商缓存**

     **强制缓存**是向浏览器查询结果，并根据缓存规则决定是否使用。

     当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control（http/1.1）优先级比Expires（http/1.0）高。

     **协商缓存**就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，服务器根据缓存标识决定是否使用缓存。

     协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match。其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高，同时存在则只有Etag / If-None-Match生效。

      ![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494623-5e22c25c-7fef-4568-b970-69dfd58199dd.webp) 

     

2. DNS解析（这⼀部分涉及到dns查询， TCP/IP 请求， 五层因特⽹协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以 及后台内部的处理等等）

4. 后台和前台的 HTTP 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）

6. 浏览器接收到 HTTP 数据包后的解析流程（解析 html -词法分析然后解析成 dom 树、解 析 css ⽣成 css 规则树、合并成 render 树，然后 layout 、 painting 渲染、复合图 层的合成、 GPU 绘制、外链资源的处理、 loaded 和 DOMContentLoaded 等）

7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）

8. JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作 ⽤域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）

   **跨域解决方案：**

   - 利用Node中间件
   - Nginx反向代理
   - JSONP标签跨域访问
   - WebSocket
   - postMassage
   - 后端设置CORS

## OSI七层模型/TCP四层模型

- ### OSI七层模型

  物理层：

  数据链路层：

  网络层：

  运输层：

  会话层：

  表示层：

  应用层：

- ### TCP四层模型

  网络接口层：

  网际层：

  运输层：

  应用层：

## HTTP与HTTPS

### HTTP

-  HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。 

- 特点：无状态、明文、不安全

- HTTP1.1支持长连接，管道网络传输减少响应时间，但要造成队头阻塞能够使用同一个域名建立多个持久连接（chrome是六个）解决

- 优化：利用缓存技术尽量避免http请求；

  ​		   利用代理服务器减少重定向次数，使用打包工具减少请求次数，

  ​		   数据压缩

### HTTPS

-  HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。
-  透明性：混合加密；完整性：摘要算法；真实性：数字证书；
- 密钥交换算法：RSA（安全性较差，不支持前向加密）、ECDHE（更好）

### 区别

- HTTPS在HTTP和TCP之间加入SSL/TLS安全协议，加密传输数据
- HTTPS需要经历TCP握手和SSL/TLS握手才能进行加密传输
- HTTP服务器监听80端口；HTTPS服务器监听443端口
- 使用HTTPS的服务器需要向CA申请数字证书

## WebSocket

- #### 是什么？

  HTML5开始提供的一种浏览器与服务器进行<font color="pink">全双工通信的通信协议</font>，复用HTTP握手信道（通过HTTP请求报文升级通信服务协议）

- #### 优点？

  可以发送⽂本，也可以⼆进制⽂件 

  相比于http1.0的短连接和1.1的长连接，<font color="pink">实时性更强</font>

  相比于http每次都要携带完整的请求头，<font color="pink">控制开销更少</font>

  无跨域问题

  支持扩展

- #### 应用场景

  弹幕、聊天室

  ```javascript
  const ws = new Websocket();
  ```


# 性能优化

前言：

 	DOM对象本身也是一个js对象，所以严格来说，**并不是操作这个对象慢，而是说操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）**。 

## 优化浏览器操作

### Layout（回流、布局）优化：

- 读写`DOM`分离操作分离

- 样式集中修改

  正常情况下，JS引擎线程与GUI线程是互斥的，当JS解析脚本时，对DOM的任何修改都会暂存起来，当js执行上下文完成执行后，根据暂存数据进行一次layout。然而当js执行立即获取最新DOM节点信息操作时，主线程就需要提前进行layout。

  [为什么操作DOM很慢？]: https://juejin.cn/post/6844903825774493703

  

- 缓存需要修改的`DOM`元素

   DOM操作是非常珍贵的，对资源开销也比较大。最好的办法就是查询一次保存在变量当中。而不要为了节省内存开销不去设置变量 

  ```javascript
  //例如在图片懒加载时，将DOM元素暂存到一个变量中
  let imgs = document.querySelectorAll('img');
  
  const Lazyload = (function(){
      let count = 0;//用于变量回收
      return function(imgs){
          let delete = [];
          imgs.forEach( item => {
  			if(item.getBoundingClientRect().top < window.innerHeight){
                  item.src = item.dataset.src;
                  delete.push(index);
                  if(count === imgs.length){
                      document.removeEventListener('scorll',Lazyload);
                  }
              }
          })
          imgs = imgs.filter((item,index) => !delete.includes(index))
      }
  })()
  
  function debounce(func,delay){
      let timer;
      return ()=>{
          let args = arguments;
          clearTimeout(timer);
          timer = setTimeout(()=>{
              func.call(this,args);
          },delay)
      }
  }
  
  document.addEventListener('scroll',debounce(Lazyload,1000));
  ```

  

- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上

    因为`transform`属于合成属性，对合成属性进行`transition/animate`动画 `transform` 不重绘，不回流 

## 优化网络请求操作

![1638521217772](C:\Users\AllenYan\AppData\Roaming\Typora\typora-user-images\1638521217772.png)

### 多使用内存、缓存等持久化数据的方法

​	减少网络请求、CPU的计算

### 多利用 **CDN静态资源加速** 	

​	 CDN 是一个内容分发网络，通过对源网站资源的缓存， 用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，  有利于提高网站的访问速度和服务器负载均衡。

​	 把静态资源（js，css，img）托管在CDN服务器上 

## 代码优化

### 防抖

```javascript
function debounce(func,delay){
    let timer;
    return ()=>{
        let args = arguments;
        clearTimeout(timer);
        timer = setTimeout(()=>{
            func.apply(this,args);
        },delay)
    }
}
```

### 节流

```javascript
/*方式一：利用定时器标志位*/
function throttle(func,delay){
    let timer;
    return ()=>{
        let args = arguments;
        if(timer) return;
        timer = setTimeout(()=>{
            func.apply(this,args);
            timer = null;
        },delay)
    }
}

/*方式二：利用时间戳*/
function throttle(func,delay){
    let pre;
    return ()=>{
        let args = arguments;
        let now = new Date();
        if(now - pre > delay){
            func.apply(this,args);
            pre = now;
        }
    }
}
```

### 懒加载

```javascript
/*利用IntersrctionObserve*/
let imgs = [...document.querySelectorAll('img')];

const Lazyload = function(imgs){
    //创建实例
    let obersever = new IntersectionObeserve(entries => {
        entries.forEach( entry =>{
            if(entry.isIntersecimg){
                entry.target.src = entry.target.dataset.src;
                obersever.unobserve(img);
            }
        })
    })
    
    //绑定实例
    imgs.forEach( img =>{
        obersever.observe(img);
    })
}
```

### 预加载

# Web安全

[资料参考]: https://juejin.cn/post/6844903685122703367#heading-14

[视频参考]: https://www.bilibili.com/video/BV1LJ411G7Lp?p=6

## xss

​	**概念**：跨站脚本攻击，是一种代码注入攻击。在目标网站中植入恶意代码，当被攻击者登陆网站时就会执行恶意代码， 这些脚本可以读取 `cookie，session tokens`，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 

### 分类

- 存储型：常用在博客、输入框之类的，攻击者在博客中写入html相关代码，上传到目标网站，受害者点击博客，请求页面时，下载html资源，浏览器解析时，会将攻击者写入得html代码解析，从而实现攻击。

  1.攻击者将恶意代码提交到目标网站数据库

  2.用户打开目标网站，网站服务器端将恶意代码从数据库中取出拼接带HTML中，返回给浏览器

  3.用户浏览器接收到后，解析执行的同时恶意代码也被执行。

  4.恶意代码窃取用户本地信息并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  ![1638530381386](C:\Users\AllenYan\AppData\Roaming\Typora\typora-user-images\1638530381386.png)

- 反射型：通常时通过URL传参的地方，例如网站搜索、跳转

   反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 <font color="pink">需要诱导用户去点击包含恶意代码的URL，将恶意代码作为参数拼接到响应HTML，实现注入</font>

- DOM型（前端安全漏洞）

   DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 

  1.攻击者构建包含恶意代码的URL

  2.用户打开URL，用户浏览器接收到响应解析，前端JS取出URL中的恶意代码并执行。

   DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

### 预防XSS

1. **对非法标签输入过滤**

   输入过滤并非完全可靠，当对于明确输入类型时，是有必要的。

2. **防止HTML注入**

   在存储型和反射性XSS攻击中，攻击者通过返回带有恶意代码的HTML，浏览器解析执行从而实现攻击。

   - 改成纯前端渲染，将代码和数据分隔开。

     JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。通过调用明确的方法来高度浏览器要设置文本、属性、还是样式；但同样需注意避免 DOM 型 XSS 漏洞`onload`、`href`等 

   - 对HTML进行充分的转义。

      对用户输入得特殊标签进行转义，把 `& < > " ' /` 这几个字符转义掉 

     ![1638531816572](C:\Users\AllenYan\AppData\Roaming\Typora\typora-user-images\1638531816572.png)

3. **防止JS执行时，执行恶意代码**

   ​	避免使用`.innerHTMl`、 `.document.write()`，不要把不可信的数据插入插入到页面中，而尽量使用`.textContent`、`.setAttribute()`等。

   ​	使用Vue或者React技术栈时，在render阶段避免使用`.innerHTMl`、`.document.write()`

   ​	

   ```javascript
   <!-- 内联事件监听器中包含恶意代码 -->
   <img onclick="UNTRUSTED" onerror="UNTRUSTED" src="data:image/png,">
   
   <!-- 链接内包含恶意代码 -->
   <a href="UNTRUSTED">1</a>
   
   <script>
   // setTimeout()/setInterval() 中调用恶意代码
   setTimeout("UNTRUSTED")
   setInterval("UNTRUSTED")
   
   // location 调用恶意代码
   location.href = 'UNTRUSTED'
   
   // eval() 中调用恶意代码
   eval("UNTRUSTED")
   </script>其他预防措施
   ```

### 其他防范措施

- 设置cookie的HTTP-Only属性：禁止JS读取敏感cookie，攻击者完成XSS注入也无法窃取此cookie

- 验证码：防止XSS攻击冒充用户提交

- 设置输入内容长度：对于不信任输入设置合理长度，增加XSS攻击难度

- CSP（Content Security Policy）:

  ![1638532624145](C:\Users\AllenYan\AppData\Roaming\Typora\typora-user-images\1638532624145.png)

### XSS攻击测试

- ​	使用扫描工具自动检测 XSS 漏洞 

[测试工具]: https://github.com/mozilla/observatory-cli

- ​	 使用通用 XSS 攻击字符串手动检测 XSS 漏洞 

  ```javascript
  jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e
  ```

   只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测 

## CSRF

概念：诱导用户进入第三方网站（往往与被攻击网站同源），在第三方网站中向被攻击网站发送跨站请求。冒充用户对被攻击网站执行操作。

### 分类

- GET类型的CSRF

  GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：

  ```markdown
   <img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
  ```

  在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。<font color="pink">bank.example就会收到包含受害者登录信息的一次跨域请求。</font>

- POST类型的CSRF

   这种类型的CSRF通常使用的是一个自动提交的表单，如： 

  ```markdown
   <form action="http://bank.example/withdraw" method=POST>
      <input type="hidden" name="account" value="xiaoming" />
      <input type="hidden" name="amount" value="10000" />
      <input type="hidden" name="for" value="hacker" />
  </form>
  <script> document.forms[0].submit(); </script> 
  ```
  

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

- 链接类型的CSRF

   这种需要用户点击链接才会触发 ，通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招 

### 特点

- 通常是由第三方网站发起，被攻击网站无法防止攻击发生。
- 利用受害者登陆凭证，冒充受害者提交操作
- 不能直接获取受害者登陆凭证，仅仅是冒充

### 防护措施

1.  同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。 通过referer头查看网站访问来源

2. 针对第三方网站冒充用户， 每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。 发送请求时，携带token。

# Webpack

## 常用loader

- style-loader:
- css-loader
- less-loader
- html-loader
- file-loader
- url-loader
- postcss-loader
- images-loader
- eslint-loader
- tslint-loader